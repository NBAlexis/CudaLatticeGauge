\subsection{\label{hmc}\index{hmc}hmc}

HMC is short for hybrid Monte Carlo.

\subsubsection{\label{hmc_scheme}Basic idea}

Treating $SU(N)$ matrix $U$ on links as coordinate, HMC will generate a pair of configurations, $(P,U)$, where $P$ is momentum and $P\in \mathfrak{su}(N)$.

One can:

(1) Create a random $P$.

(2) Obtain $\dot{P}$, $\dot{U}$. Note that, dot is $d/d\tau$, where $\tau$ is `Markov time'.

(3) Numerically evaluate the differential equation, and use a Metropolis accept / reject to update.

\begin{itemize}
\item \index{force}Force
\end{itemize}

Defined by Newton, $dp/dt$ is a force, so in CLG, $\dot{P}$ is called `force'. See Eqs.~(2.53), (2.56) and (2.57) of Ref.~\cite{latticeqcdbook2017}, for $SU(N)$,
\begin{equation}
\begin{split}
&F_{\mu}(x)=\dot{P}_{\mu}(x)=-\frac{\beta}{2N}\{U_{\mu}(x)\Sigma _{\mu}(x)\}_{TA}\\
&\{W\}_{TA}=\frac{W-W^{\dagger}}{2}-{\rm tr}\left(\frac{W-W^{\dagger}}{2N}\right){\bf I}\\
\end{split}
\label{eq.hmc.force}
\end{equation}
where ${\bf I}$ is identity matrix, $\Sigma$ is the `Staple'.

\begin{itemize}
\item \index{Integrator}Integrator
\end{itemize}

Knowing $\dot{P}$, and $\dot {U}$, to obtain $U$ and $P$ is simply
\begin{equation}
\begin{split}
&U(\tau+d\tau)\approx \dot{U}d\tau + U(\tau),\;\;P(\tau+d\tau)\approx \dot{P}d\tau + P(\tau)\\
\end{split}
\end{equation}

A more accurate calculation is done by integrator, for example, the leap frog integrator, the $M$ step leap frog integral is described in Ref.~\cite{latticeqcdbook2010},
\begin{subequations}
\begin{eqnarray}
&\epsilon = \frac{\tau}{M}\\
&U_{\mu}(x,(n+1)\epsilon)=U_{\mu}(x,n\epsilon)+\epsilon P_{\mu}(x,n\epsilon)+\frac{1}{2}F_{\mu}(x,n\epsilon)\epsilon ^2\\
&P_{\mu}(x,(n+1)\epsilon)=P_{\mu}(x,n\epsilon)+\frac{1}{2}\left(F_{\mu}(x,(n+1)\epsilon)+F_{\mu}(x,n\epsilon)\right)\epsilon
\end{eqnarray}
\label{eq.hmc.update_basic}
\end{subequations}

So, knowing $U(n\epsilon)$ we can calculate $F(n\epsilon)$ using Eq.~(\ref{eq.hmc.force}).
Knowing $U(n\epsilon),P(n\epsilon),F(n\epsilon)$, we can calculate $U((n+1)\epsilon)$ using Eq.~(\ref{eq.hmc.update_basic}).b.
Then we are able to calculate $F((n+1)\epsilon)$ again using Eq.~(\ref{eq.hmc.force}).
Then we can calculate $P((n+1)\epsilon)$ using Eq.~(\ref{eq.hmc.update_basic}).c.


\subsubsection{\label{Leap frog}\index{leap frog}Leap frog integrator}

In Sec.~\ref{hmc_scheme}, the basic idea is introduced. However, the implementation is slightly different. The pseudo code can be written as 

\lstset{
    numbers=left,
    numberstyle= \tiny,
    keywordstyle= \color{ blue!70},
    commentstyle= \color{red!50!green!50!blue!50},
    frame=single,
    rulesepcolor= \color{ red!20!green!20!blue!20} ,
    escapeinside=``,
    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
    framexleftmargin=2em,
    language=[5.3]Lua,
    breaklines=true,
    columns=fullflexible,
    captionpos=b,
    basicstyle=\footnotesize\ttfamily,
}

\begin{lstlisting}
-- Exchange Strength is constant
function GetJValueByLatticeIndex(x, y)
    return 2.0
end

-- Need to register the function
return {
    GetJValueByLatticeIndex = GetJValueByLatticeIndex,
}
\end{lstlisting}