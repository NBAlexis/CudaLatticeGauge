\subsection{\label{hmc}\index{hmc}HMC}

HMC is abbreviation for hybrid Monte Carlo.

\subsubsection{\label{hmc_scheme}The fermion action}

Cooperating with HMC, the fermion is usually the 'Pseudofermions`.

\subsubsection{\label{hmc_scheme}Basic idea}

Treating $SU(N)$ matrix $U$ on links as coordinate, HMC will generate a pair of configurations, $(P,U)$, where $P$ is momentum and $P\in \mathfrak{su}(N)$.

One can:

(1) Create a random $P$.

(2) Obtain $\dot{P}$, $\dot{U}$. Note that, dot is $d/d\tau$, where $\tau$ is `Markov time'.

(3) Numerically evaluate the differential equation, and use a Metropolis accept / reject to update.

\begin{itemize}
\item \index{force}Force
\end{itemize}

Defined by Newton, $dp/dt$ is a force, so in CLG, $\dot{P}$ is called `force'. See Eqs.~(2.53), (2.56) and (2.57) of Ref.~\cite{latticeqcdbook2017}, for $SU(N)$,
\begin{equation}
\begin{split}
&F_{\mu}(x)=\dot{P}_{\mu}(x)=-\frac{\beta}{2N}\{U_{\mu}(x)\Sigma _{\mu}(x)\}_{TA}\\
&\{W\}_{TA}=\frac{W-W^{\dagger}}{2}-{\rm tr}\left(\frac{W-W^{\dagger}}{2N}\right){\bf I}\\
\end{split}
\label{eq.hmc.force}
\end{equation}
where ${\bf I}$ is identity matrix, $\Sigma$ is the `Staple'.

\begin{itemize}
\item \index{Integrator}Integrator
\end{itemize}

Knowing $\dot{P}$, and $\dot {U}$, to obtain $U$ and $P$ is simply
\begin{equation}
\begin{split}
&U(\tau+d\tau)\approx \dot{U}d\tau + U(\tau),\;\;P(\tau+d\tau)\approx \dot{P}d\tau + P(\tau)\\
\end{split}
\end{equation}

A more accurate calculation is done by integrator, for example, the leap frog integrator, the $M$ step leap frog integral is described in Ref.~\cite{latticeqcdbook2010},
\begin{subequations}
\begin{eqnarray}
&\epsilon = \frac{\tau}{M}\\
&U_{\mu}(x,(n+1)\epsilon)=U_{\mu}(x,n\epsilon)+\epsilon P_{\mu}(x,n\epsilon)+\frac{1}{2}F_{\mu}(x,n\epsilon)\epsilon ^2\\
&P_{\mu}(x,(n+1)\epsilon)=P_{\mu}(x,n\epsilon)+\frac{1}{2}\left(F_{\mu}(x,(n+1)\epsilon)+F_{\mu}(x,n\epsilon)\right)\epsilon
\end{eqnarray}
\label{eq.hmc.update_basic}
\end{subequations}

So, knowing $U(n\epsilon)$ we can calculate $F(n\epsilon)$ using Eq.~(\ref{eq.hmc.force}).
Knowing $U(n\epsilon),P(n\epsilon),F(n\epsilon)$, we can calculate $U((n+1)\epsilon)$ using Eq.~(\ref{eq.hmc.update_basic}).b.
Then we are able to calculate $F((n+1)\epsilon)$ again using Eq.~(\ref{eq.hmc.force}).
Then we can calculate $P((n+1)\epsilon)$ using Eq.~(\ref{eq.hmc.update_basic}).c.


\subsubsection{\label{Leap frog}\index{leap frog}Leap frog integrator}

In Sec.~\ref{hmc_scheme}, the basic idea is introduced. However, the implementation is slightly different.
\begin{subequations}
\begin{eqnarray}
&U_{\mu}(0,x)=gauge(x),\;\;P_{\mu}(0,x)=i\sum _{a}r_a(\mu,x)T_a\\
&F_{\mu}(n\epsilon,x)=-\frac{\beta}{2N}\{U_{\mu}(n\epsilon,x)\Sigma _{\mu}(n\epsilon,x)\}_{TA}\\
&P_{\mu}(\frac{1}{2}\epsilon,x)=P_{\mu}(0,x)+\frac{\epsilon}{2}F_{\mu}(0,x)\\
&U_{\mu}((n+1)\epsilon,x)=\exp \left(\epsilon P_{\mu}((n+\frac{1}{2})\epsilon,x)\right)U_{\mu}(n\epsilon,x)\\
&P_{\mu}((n+\frac{1}{2})\epsilon,x)=P_{\mu}((n-\frac{1}{2})\epsilon,x)+\epsilon F_{\mu}(n\epsilon,x)
\end{eqnarray}
\label{eq.hmc.update_leapfrog}
\end{subequations}
or simply written as
\begin{equation}
\begin{split}
&P_{\epsilon}\circ U_{\epsilon}\circ P_{\frac{1}{2}\epsilon}\left(P_0,U_0\right)
\end{split}
\label{eq.hmc.update_leapfrog2}
\end{equation}
The pseudo code can be written as

\begin{lstlisting}

FieldGauge field = gaugeField.copy();

//sum _i i r_i T_i, where r_i are random numbers generated by Gaussian distribution
FieldGauge momentumField = FieldGauge::RandomGenerator();

//First half update
FieldGauge forceField = FieldGauge::Zero();
for (int i = 0; i < m_lstActions.Num(); ++i)
{
    forceField += m_lstActions[i]->CalculateForceOnGauge(field);
}
//momentumField = momentumField + 0.5f * epsilon * forceField
momentumField.Axpy(fStep * 0.5f, forceField);

for (int i = 1; i < steps + 1; ++i)
{
    field = FieldGauge::Exp(fStep * momentumField) * field;
    forceField = FieldGauge::Zero();
    for (int j = 0; j < m_lstActions.Num(); ++j)
    {
        forceField += m_lstActions[j]->CalculateForceOnGauge(field);
    }
    momentumField.Axpy((j < steps) ? fStep : (fStep * 0.5f), forceField);
}

\end{lstlisting}

\subsubsection{\label{Omelyan}\index{Omelyan}Omelyan integrator}

The Omelyan integrator can be simply written as (c.f. Eq.~(2.80) of Ref.~\cite{latticeqcdbook2017})
\begin{equation}
\begin{split}
&P_{\lambda\epsilon}\circ U_{\frac{1}{2}\epsilon}\circ P_{(1-2\lambda)\epsilon}\circ U_{\frac{1}{2}\epsilon}\circ P_{\lambda\epsilon}\left(P_0,U_0\right)
\end{split}
\label{eq.hmc.update_Omelyan}
\end{equation}
with
\begin{equation}
\begin{split}
&\lambda = \frac{1}{2}-\frac{\left(2\sqrt{326}+36\right)^{\frac{1}{3}}}{12}+\frac{1}{6\left(2\sqrt{326}+36\right)^{\frac{1}{3}}}\approx 0.19318332750378364
\end{split}
\label{eq.hmc.update_Omelyan2}
\end{equation}
