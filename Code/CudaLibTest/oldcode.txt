
//============================================================================================

class CA
{
public:
    __device__ CA() { ; }
    __device__ ~CA() { ; }
    __device__ virtual void CallMe() { printf("This is A\n"); }
};

class CB : public CA
{
public:
    __device__ CB() : CA() { ; }
    __device__ ~CB() { ; }
    __device__ virtual void CallMe() { printf("This is B\n"); }
};

__global__ void _kernelCreateInstance(CA** pptr)
{
    (*pptr) = new CB();
}

__global__ void _kernelDeleteInstance(CA** pptr)
{
    delete (*pptr);
}

extern "C" {
    void _kCreateInstance(CA** pptr)
    {
        _kernelCreateInstance << <1, 1 >> >(pptr);
    }

    void _kDeleteInstance(CA** pptr)
    {
        _kernelDeleteInstance << <1, 1 >> >(pptr);
    }
}

__constant__ CA* m_pA;

__global__ void _kernelCallConstantFunction()
{
    m_pA->CallMe();
}


extern "C" {
    void _cKernelCallConstantFunction()
    {
        _kernelCallConstantFunction << <1, 1 >> > ();
    }
}

int main()
{
    CA** pptr;
    cudaMalloc((void**)&pptr, sizeof(CA*));
    _kCreateInstance(pptr);
    
    //I can NOT use a kernel to set m_pA = (*pptr), because it is constant.
    //I can NOT use cudaMemcpyToSymbol(m_pA, (*pptr)), because * operator on host is incorrect when pptr is a device ptr.
    //I can NOT use cudaMemcpyToSymbol(m_pA, (*pptr)) in kernel, because cudaMemcpyToSymbol is a __host__ function
    //I have to at first copy it back to host, then copy it back back again to constant
    CA* pptrHost[1];
    cudaMemcpy(pptrHost, pptr, sizeof(CA**), cudaMemcpyDeviceToHost);
    cudaMemcpyToSymbol(m_pA, pptrHost, sizeof(CA*));
    _cKernelCallConstantFunction();

    _kDeleteInstance(pptr);
    cudaFree(pptr);
    return 0;
}


//============================================================================================
__global__ void _kInitialArray(int* thearray)
{
    int iX = threadIdx.x + blockDim.x * blockIdx.x;
    int iY = threadIdx.y + blockDim.y * blockIdx.y;
    int iZ = threadIdx.z + blockDim.z * blockIdx.z;
    thearray[iX * 16 + iY * 4 + iZ] = iX * 16 + iY * 4 + iZ;
}

extern "C" {
    void _cInitialArray(int* thearray)
    {
        dim3 block(1, 1, 1);
        dim3 th(4, 4, 4);

        _kInitialArray << <block, th >> > (thearray);
        checkCudaErrors(cudaGetLastError());
    }
}

class B
{
public:
    B()
    {
        checkCudaErrors(cudaMalloc((void**)&m_pDevicePtr, sizeof(int) * 64));
        _cInitialArray(m_pDevicePtr);
    }
    ~B()
    {
        cudaFree(m_pDevicePtr);
    }
    __device__ int GetNumber(int index)
    {
        m_pDevicePtr[index] = m_pDevicePtr[index] + 1;
        return m_pDevicePtr[index];
    }
    int* m_pDevicePtr;
};

__global__ void _kAddArray(int* thearray1, B* pB)
{
    int iX = threadIdx.x + blockDim.x * blockIdx.x;
    int iY = threadIdx.y + blockDim.y * blockIdx.y;
    int iZ = threadIdx.z + blockDim.z * blockIdx.z;
    thearray1[iX * 16 + iY * 4 + iZ] = thearray1[iX * 16 + iY * 4 + iZ] + pB->GetNumber(iX * 16 + iY * 4 + iZ);
}

extern "C" {
    void _cAddArray(int* thearray1, B* pB)
    {
        dim3 block(1, 1, 1);
        dim3 th(4, 4, 4);
        _kAddArray << <block, th >> > (thearray1, pB);
        checkCudaErrors(cudaGetLastError());
    }
}

class A
{
public:
    A()
    {
        checkCudaErrors(cudaMalloc((void**)&m_pDevicePtr, sizeof(int) * 64));
        _cInitialArray(m_pDevicePtr);
    }
    ~A()
    {
        checkCudaErrors(cudaFree(m_pDevicePtr));
    }
    void Add(B* toAdd/*this should be a device ptr(new on device function or created by cudaMalloc)*/)
    {
        _cAddArray(m_pDevicePtr, toAdd);
    }
    int* m_pDevicePtr;
};



int main(int argc, char * argv[])
{
    B* pB = new B();
    A* pA = new A();
    B* pDeviceB;
    checkCudaErrors(cudaMalloc((void**)&pDeviceB, sizeof(B)));
    checkCudaErrors(cudaMemcpy(pDeviceB, pB, sizeof(B), cudaMemcpyHostToDevice));
    pA->Add(pDeviceB);
    int* res = (int*)malloc(sizeof(int) * 64);
    checkCudaErrors(cudaMemcpy(res, pA->m_pDevicePtr, sizeof(int) * 64, cudaMemcpyDeviceToHost));
    printf("----------- A=");
    for (int i = 0; i < 8; ++i)
    {
        printf("\n");
        for (int j = 0; j < 8; ++j)
            printf("res %d=%d  ", i * 8 + j, res[i * 8 + j]);
    }
    printf("\n");
    //NOTE: We are getting data from pB, not pDeviceB, this is OK, ONLY because m_pDevicePtr is a pointer
    checkCudaErrors(cudaMemcpy(res, pB->m_pDevicePtr, sizeof(int) * 64, cudaMemcpyDeviceToHost));
    printf("----------- B=");
    for (int i = 0; i < 8; ++i)
    {
        printf("\n");
        for (int j = 0; j < 8; ++j)
            printf("res %d=%d  ", i * 8 + j, res[i * 8 + j]);
    }
    printf("\n");
    delete pA;
    delete pB;
    return 0;
}

//============================================================================================
test kernel excute order

__global__ void _kernelInitial(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] = 1;
}


__global__ void _kernelPluseOne(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] += 1;
}

__global__ void _kernelMultiplyTwo(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] *= 2;
}


extern "C" {
    void _cKernelInitial(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelInitial << <dblock, dthread >> > (output, 16, 1);
    }

    void _cKernelPlusOne(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
    }

    void _cKernelMultiplyTwo(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
    }
}

class CA
{
public:
    void TestMemberFunction(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);

        _kernelInitial << <dblock, dthread >> > (output, 16, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
    }
};

int main()
{
    int * pTable;
    cudaMalloc((void**)&pTable, sizeof(int) * 256);
    //_cKernelInitial(pTable);
    //_cKernelPlusOne(pTable);
    //_cKernelMultiplyTwo(pTable);
    //_cKernelPlusOne(pTable);
    //_cKernelMultiplyTwo(pTable);

    CA calc;
    calc.TestMemberFunction(pTable);

    int outData[256];
    cudaMemcpy(outData, pTable, sizeof(int) * 256, cudaMemcpyDeviceToHost);
    
    printf("res=\n");
    for (int i = 0; i < 16; ++i)
    {
        for (int j = 0; j < 16; ++j)
        {
            printf("%d ", outData[i * 16 + j]);
        }
        printf("\n");
    }

    cudaFree(pTable);
    return 0;
}

//===========================================================================
//test union
struct TestStructure
{
    __device__ TestStructure()
    {
        memberf[0] = memberf[2] = memberf[4] = 1.0f;
        memberf[1] = memberf[3] = memberf[5] = 0.0f;
    }

    void __device__ debugPrint()
    {
        printf("c1=%f+%fi, c2=%f+%fi, c3=%f+%fi\n", memberC[0].x, memberC[0].y, memberC[1].x, memberC[1].y, memberC[2].x, memberC[2].y);
    }

    union
    {
        cuComplex memberC[3];
        float memberf[6];
    };
    
};

struct TableTest
{
    __device__ TableTest()
    {

    }

    void __device__ Initial()
    {
        for (int i = 0; i < 10; ++i)
        {
            memberS[i] = TestStructure();
        }
    }

    void __device__ Print()
    {
        for (int i = 0; i < 10; ++i)
        {
            printf("r:%f,%f,%f,%f,%f,%f\nc:%f,%f,%f,%f,%f,%f\n",
                memberf[6 * i + 0],
                memberf[6 * i + 1],
                memberf[6 * i + 2],
                memberf[6 * i + 3],
                memberf[6 * i + 4],
                memberf[6 * i + 5],
                memberC[3 * i + 0].x,
                memberC[3 * i + 0].y,
                memberC[3 * i + 1].x,
                memberC[3 * i + 1].y,
                memberC[3 * i + 2].x,
                memberC[3 * i + 2].y);

            memberS[i].debugPrint();
        }
    }

    union
    {
        TestStructure memberS[10];
        cuComplex memberC[30];
        float memberf[60];
    };
};

void __global__ CreateA(void* devicePtr)
{
    ((TableTest*)devicePtr)->Initial();
    ((TableTest*)devicePtr)->Print();

    printf("\n");
}

void __global__ CreateB()
{
    TableTest* devicePtr2 = new TableTest();
    devicePtr2->Initial();
    devicePtr2->Print();
    delete devicePtr2;

    printf("\n");
}

int main()
{
    float* buffer1;
    cuComplex* buffer2;
    TestStructure* buffer3;
    TableTest* buffer4;

    cudaMalloc((void**)&buffer1, sizeof(float) * 60);
    cudaMalloc((void**)&buffer2, sizeof(cuComplex) * 30);
    cudaMalloc((void**)&buffer3, sizeof(TestStructure) * 10);
    cudaMalloc((void**)&buffer4, sizeof(TableTest) * 1);

    CreateA << <1, 1 >> > ((void*)buffer1);
    CreateA << <1, 1 >> > ((void*)buffer2);
    CreateA << <1, 1 >> > ((void*)buffer3);
    CreateA << <1, 1 >> > ((void*)buffer4);

    CreateB << <1, 1 >> >();

    cudaFree(buffer1);
    cudaFree(buffer2);
    cudaFree(buffer3);
    cudaFree(buffer4);
}


==============================================================================================

class alignas(8) ClassABC
{
public:
    __host__ __device__ ClassABC():m_iValue(0){ ;  }
    __device__ void Add(int v)
    {
        m_iValue += v;
        m_bySomeTag = static_cast<byte>(m_iValue & 0x11);
    }
    __device__ void DebugPrint() const
    {
        printf("%d,%d;", m_iValue, m_bySomeTag);
    }
    int m_iValue;
    byte m_bySomeTag;
};

class alignas(256) ClassDEF
{
public:
    __host__ __device__ ClassDEF() { ; }

    __device__ void Add(int v)
    {
        m_abc[10].Add(v);
        //m_values[10] += v; also work
    }

    __device__ void DebugPrint() const
    {
        m_abc[10].DebugPrint();
    }
    //Witout warning
    //device: ClassABC 4, ClassDEF 0
    //host: ClassABC 4, ClassDEF 80
    union 
    {
        ClassABC m_abc[20];
        int m_values[40];
    };

    //With warning
    //Output:
    //device: ClassABC 4, ClassDEF 0
    //host: ClassABC 4, ClassDEF 80
    //ClassABC m_abc[20];
};

__global__ void TestFunc()
{
    ClassDEF def[5];
    printf("device: ClassABC %d, ClassDEF %d\n", sizeof(ClassABC), sizeof(ClassDEF));

    for (int i = 0; i < 5; ++i)
    {
        def[i].Add(i);
        def[i].DebugPrint();
    }
}

int main()
{
    printf("host: ClassABC %d, ClassDEF %d\n", sizeof(ClassABC), sizeof(ClassDEF));

    //If use the version with warning, must set stack size, or there will be a stackoverflow.
    //checkCudaErrors(cudaDeviceSetLimit(cudaLimitStackSize, 1 << 16));
    TestFunc << <1, 1 >> > ();
    checkCudaErrors(cudaDeviceSynchronize());
    return 0;
}



//==================================== classical M S ====================================================

#include "CudaHelper.h"

#define _XD 11
#define _YD 5

//Single Block
__global__ void _kernelSmallMatrixMult(cuComplex* res, 
    const cuComplex* __restrict__ left, 
    const cuComplex* __restrict__ right, 
    int dx, int dy)
{
    int x = threadIdx.x;
    int y = threadIdx.y;
    //dx=11, dy=5

    res[x * dy + y] = make_cuComplex(0.0f, 0.0f);

    for (int i = 0; i < dy; ++i)
    {
        res[x * dy + y] = cuCaddf(res[x * dy + y], 
            cuCmulf(left[x * dy + i], right[i * dy + y]));
    }
}


__global__ void _kernelInitialR(cuComplex* R, int dy)
{
    int i = threadIdx.x;
    int j = threadIdx.y;
    R[i * dy + j] = make_cuComplex(0.0f, 0.0f);
}

__global__ void _kernelEachLineR(const cuComplex* __restrict__ Q, cuComplex* R, int i, int dx, int dy)
{
    int j = threadIdx.x;
    int n = threadIdx.y;

    if (i <= j)
    {
        cuComplex toAdd = cuCmulf(cuConjf(Q[n * dy + i]), Q[n * dy + j]);
        atomicAdd(&R[i * dy + j].x, toAdd.x);
        atomicAdd(&R[i * dy + j].y, toAdd.y);
    }
}

__global__ void _kernelCMSProj(cuComplex* Q, const cuComplex* __restrict__ R, int i, int dx, int dy)
{
    int j = threadIdx.x;
    int n = threadIdx.y;

    if (i > j)
    {
        cuComplex toAdd = cuCmulf(R[j * dy + i], Q[n * dy + j]);
        atomicAdd(&Q[n * dy + i].x, -toAdd.x / R[j * dy + j].x);
        atomicAdd(&Q[n * dy + i].y, -toAdd.y / R[j * dy + j].x);
    }
}

__global__ void _kernelCMSNorm(cuComplex* Q, cuComplex* R, int dx, int dy)
{
    __shared__ float length[_YD];
    int i = threadIdx.x;
    int n = threadIdx.y;

    Q[n * dy + i].x = Q[n * dy + i].x / R[i * dy + i].x;
    Q[n * dy + i].y = Q[n * dy + i].y / R[i * dy + i].x;
}

void PrintMatrix(const cuComplex* mtr, int dx, int dy)
{
    printf("\n");
    for (int i = 0; i < dx; ++i)
    {
        for (int j = 0; j < dy; ++j)
        {
            printf("%1.3f %s %1.3f I   ", mtr[i * dy + j].x, mtr[i * dy + j].y < 0.0f ? "" : "+", mtr[i * dy + j].y);
        }
        printf("\n");
    }
}

int main()
{
    cuComplex hij[_XD * _YD];
    cuComplex pij[_YD * _YD];
    cuComplex hpij[_XD * _YD]; 
    cuComplex rij[_YD * _YD];
    cuComplex qij[_XD * _YD];
    cuComplex rescheckij[_XD * _YD];
    for (int i = 0; i < _XD * _YD; ++i)
    {
        hij[i].x = (rand() % 11 - 5) / 5.0f;
        hij[i].y = (rand() % 11 - 5) / 5.0f;
        if (i < _YD * _YD)
        {
            pij[i].x = (rand() % 11 - 5) / 5.0f;
            pij[i].y = (rand() % 11 - 5) / 5.0f;
        }
    }
    cuComplex* deviceH = NULL;
    cuComplex* deviceP = NULL;
    cuComplex* deviceHP = NULL;
    cuComplex* deviceQ = NULL;
    cuComplex* deviceR = NULL;
    cuComplex* deviceRes = NULL;
    checkCudaErrors(cudaMalloc((void**)&deviceH, sizeof(cuComplex) * _XD * _YD));
    checkCudaErrors(cudaMalloc((void**)&deviceP, sizeof(cuComplex) * _YD * _YD));
    checkCudaErrors(cudaMalloc((void**)&deviceHP, sizeof(cuComplex) * _XD * _YD));
    checkCudaErrors(cudaMalloc((void**)&deviceQ, sizeof(cuComplex) * _XD * _YD));
    checkCudaErrors(cudaMalloc((void**)&deviceR, sizeof(cuComplex) * _YD * _YD));
    checkCudaErrors(cudaMalloc((void**)&deviceRes, sizeof(cuComplex) * _XD * _YD));
    checkCudaErrors(cudaMemcpy(deviceH, hij, sizeof(cuComplex) * _XD * _YD, cudaMemcpyHostToDevice));
    checkCudaErrors(cudaMemcpy(deviceP, pij, sizeof(cuComplex) * _YD * _YD, cudaMemcpyHostToDevice));
    dim3 block(1, 1, 1);
    dim3 thread(_XD, _YD, 1);
    dim3 thread2(_YD, 1, 1);
    dim3 thread3(_YD, _YD, 1);
    dim3 thread4(_YD, _XD, 1);

    _kernelSmallMatrixMult << <block, thread >> > (deviceHP, deviceH, deviceP, _XD, _YD);
    _kernelInitialR << <block, thread3 >> > (deviceR,  _YD);
    checkCudaErrors(cudaMemcpy(deviceQ, deviceHP, sizeof(cuComplex) * _XD * _YD, cudaMemcpyDeviceToDevice));
    for (int j = 0; j < _YD; ++j)
    {
        _kernelEachLineR << <block, thread4 >> > (deviceQ, deviceR, j, _XD, _YD);
        if (j < _YD - 1)
        {
            _kernelCMSProj << <block, thread4 >> > (deviceQ, deviceR, j + 1, _XD, _YD);
        }
    }

    _kernelCMSNorm << <block, thread4 >> > (deviceQ, deviceR, _XD, _YD);

    _kernelSmallMatrixMult << <block, thread >> > (deviceRes, deviceQ, deviceR, _XD, _YD);

    checkCudaErrors(cudaMemcpy(hpij, deviceHP, sizeof(cuComplex) * _XD * _YD, cudaMemcpyDeviceToHost));
    checkCudaErrors(cudaMemcpy(rij, deviceR, sizeof(cuComplex) * _YD * _YD, cudaMemcpyDeviceToHost));
    checkCudaErrors(cudaMemcpy(qij, deviceQ, sizeof(cuComplex) * _XD * _YD, cudaMemcpyDeviceToHost));
    checkCudaErrors(cudaMemcpy(rescheckij, deviceRes, sizeof(cuComplex) * _XD * _YD, cudaMemcpyDeviceToHost));

    PrintMatrix(hij, _XD, _YD);
    PrintMatrix(pij, _YD, _YD);
    PrintMatrix(hpij, _XD, _YD);
    PrintMatrix(rij, _YD, _YD);
    PrintMatrix(qij, _XD, _YD);
    PrintMatrix(rescheckij, _XD, _YD);

    return 0;
}
