
//============================================================================================

class CA
{
public:
    __device__ CA() { ; }
    __device__ ~CA() { ; }
    __device__ virtual void CallMe() { printf("This is A\n"); }
};

class CB : public CA
{
public:
    __device__ CB() : CA() { ; }
    __device__ ~CB() { ; }
    __device__ virtual void CallMe() { printf("This is B\n"); }
};

__global__ void _kernelCreateInstance(CA** pptr)
{
    (*pptr) = new CB();
}

__global__ void _kernelDeleteInstance(CA** pptr)
{
    delete (*pptr);
}

extern "C" {
    void _kCreateInstance(CA** pptr)
    {
        _kernelCreateInstance << <1, 1 >> >(pptr);
    }

    void _kDeleteInstance(CA** pptr)
    {
        _kernelDeleteInstance << <1, 1 >> >(pptr);
    }
}

__constant__ CA* m_pA;

__global__ void _kernelCallConstantFunction()
{
    m_pA->CallMe();
}


extern "C" {
    void _cKernelCallConstantFunction()
    {
        _kernelCallConstantFunction << <1, 1 >> > ();
    }
}

int main()
{
    CA** pptr;
    cudaMalloc((void**)&pptr, sizeof(CA*));
    _kCreateInstance(pptr);
    
    //I can NOT use a kernel to set m_pA = (*pptr), because it is constant.
    //I can NOT use cudaMemcpyToSymbol(m_pA, (*pptr)), because * operator on host is incorrect when pptr is a device ptr.
    //I can NOT use cudaMemcpyToSymbol(m_pA, (*pptr)) in kernel, because cudaMemcpyToSymbol is a __host__ function
    //I have to at first copy it back to host, then copy it back back again to constant
    CA* pptrHost[1];
    cudaMemcpy(pptrHost, pptr, sizeof(CA**), cudaMemcpyDeviceToHost);
    cudaMemcpyToSymbol(m_pA, pptrHost, sizeof(CA*));
    _cKernelCallConstantFunction();

    _kDeleteInstance(pptr);
    cudaFree(pptr);
    return 0;
}


//============================================================================================
__global__ void _kInitialArray(int* thearray)
{
    int iX = threadIdx.x + blockDim.x * blockIdx.x;
    int iY = threadIdx.y + blockDim.y * blockIdx.y;
    int iZ = threadIdx.z + blockDim.z * blockIdx.z;
    thearray[iX * 16 + iY * 4 + iZ] = iX * 16 + iY * 4 + iZ;
}

extern "C" {
    void _cInitialArray(int* thearray)
    {
        dim3 block(1, 1, 1);
        dim3 th(4, 4, 4);

        _kInitialArray << <block, th >> > (thearray);
        checkCudaErrors(cudaGetLastError());
    }
}

class B
{
public:
    B()
    {
        checkCudaErrors(cudaMalloc((void**)&m_pDevicePtr, sizeof(int) * 64));
        _cInitialArray(m_pDevicePtr);
    }
    ~B()
    {
        cudaFree(m_pDevicePtr);
    }
    __device__ int GetNumber(int index)
    {
        m_pDevicePtr[index] = m_pDevicePtr[index] + 1;
        return m_pDevicePtr[index];
    }
    int* m_pDevicePtr;
};

__global__ void _kAddArray(int* thearray1, B* pB)
{
    int iX = threadIdx.x + blockDim.x * blockIdx.x;
    int iY = threadIdx.y + blockDim.y * blockIdx.y;
    int iZ = threadIdx.z + blockDim.z * blockIdx.z;
    thearray1[iX * 16 + iY * 4 + iZ] = thearray1[iX * 16 + iY * 4 + iZ] + pB->GetNumber(iX * 16 + iY * 4 + iZ);
}

extern "C" {
    void _cAddArray(int* thearray1, B* pB)
    {
        dim3 block(1, 1, 1);
        dim3 th(4, 4, 4);
        _kAddArray << <block, th >> > (thearray1, pB);
        checkCudaErrors(cudaGetLastError());
    }
}

class A
{
public:
    A()
    {
        checkCudaErrors(cudaMalloc((void**)&m_pDevicePtr, sizeof(int) * 64));
        _cInitialArray(m_pDevicePtr);
    }
    ~A()
    {
        checkCudaErrors(cudaFree(m_pDevicePtr));
    }
    void Add(B* toAdd/*this should be a device ptr(new on device function or created by cudaMalloc)*/)
    {
        _cAddArray(m_pDevicePtr, toAdd);
    }
    int* m_pDevicePtr;
};



int main(int argc, char * argv[])
{
    B* pB = new B();
    A* pA = new A();
    B* pDeviceB;
    checkCudaErrors(cudaMalloc((void**)&pDeviceB, sizeof(B)));
    checkCudaErrors(cudaMemcpy(pDeviceB, pB, sizeof(B), cudaMemcpyHostToDevice));
    pA->Add(pDeviceB);
    int* res = (int*)malloc(sizeof(int) * 64);
    checkCudaErrors(cudaMemcpy(res, pA->m_pDevicePtr, sizeof(int) * 64, cudaMemcpyDeviceToHost));
    printf("----------- A=");
    for (int i = 0; i < 8; ++i)
    {
        printf("\n");
        for (int j = 0; j < 8; ++j)
            printf("res %d=%d  ", i * 8 + j, res[i * 8 + j]);
    }
    printf("\n");
    //NOTE: We are getting data from pB, not pDeviceB, this is OK, ONLY because m_pDevicePtr is a pointer
    checkCudaErrors(cudaMemcpy(res, pB->m_pDevicePtr, sizeof(int) * 64, cudaMemcpyDeviceToHost));
    printf("----------- B=");
    for (int i = 0; i < 8; ++i)
    {
        printf("\n");
        for (int j = 0; j < 8; ++j)
            printf("res %d=%d  ", i * 8 + j, res[i * 8 + j]);
    }
    printf("\n");
    delete pA;
    delete pB;
    return 0;
}

//============================================================================================
test kernel excute order

__global__ void _kernelInitial(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] = 1;
}


__global__ void _kernelPluseOne(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] += 1;
}

__global__ void _kernelMultiplyTwo(int* output, int lyz, int lz)
{
    int ix = threadIdx.x + blockDim.x * blockIdx.x;
    int iy = threadIdx.y + blockDim.y * blockIdx.y;
    int iz = threadIdx.z + blockDim.z * blockIdx.z;

    output[ix * lyz + iy * lz + iz] *= 2;
}


extern "C" {
    void _cKernelInitial(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelInitial << <dblock, dthread >> > (output, 16, 1);
    }

    void _cKernelPlusOne(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
    }

    void _cKernelMultiplyTwo(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
    }
}

class CA
{
public:
    void TestMemberFunction(int* output)
    {
        dim3 dblock(2, 2, 1);
        dim3 dthread(8, 8, 1);

        _kernelInitial << <dblock, dthread >> > (output, 16, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
        _kernelPluseOne << <dblock, dthread >> > (output, 16, 1);
        _kernelMultiplyTwo << <dblock, dthread >> > (output, 16, 1);
    }
};

int main()
{
    int * pTable;
    cudaMalloc((void**)&pTable, sizeof(int) * 256);
    //_cKernelInitial(pTable);
    //_cKernelPlusOne(pTable);
    //_cKernelMultiplyTwo(pTable);
    //_cKernelPlusOne(pTable);
    //_cKernelMultiplyTwo(pTable);

    CA calc;
    calc.TestMemberFunction(pTable);

    int outData[256];
    cudaMemcpy(outData, pTable, sizeof(int) * 256, cudaMemcpyDeviceToHost);
    
    printf("res=\n");
    for (int i = 0; i < 16; ++i)
    {
        for (int j = 0; j < 16; ++j)
        {
            printf("%d ", outData[i * 16 + j]);
        }
        printf("\n");
    }

    cudaFree(pTable);
    return 0;
}

//===========================================================================
//test union
struct TestStructure
{
    __device__ TestStructure()
    {
        memberf[0] = memberf[2] = memberf[4] = 1.0f;
        memberf[1] = memberf[3] = memberf[5] = 0.0f;
    }

    void __device__ debugPrint()
    {
        printf("c1=%f+%fi, c2=%f+%fi, c3=%f+%fi\n", memberC[0].x, memberC[0].y, memberC[1].x, memberC[1].y, memberC[2].x, memberC[2].y);
    }

    union
    {
        cuComplex memberC[3];
        float memberf[6];
    };
    
};

struct TableTest
{
    __device__ TableTest()
    {

    }

    void __device__ Initial()
    {
        for (int i = 0; i < 10; ++i)
        {
            memberS[i] = TestStructure();
        }
    }

    void __device__ Print()
    {
        for (int i = 0; i < 10; ++i)
        {
            printf("r:%f,%f,%f,%f,%f,%f\nc:%f,%f,%f,%f,%f,%f\n",
                memberf[6 * i + 0],
                memberf[6 * i + 1],
                memberf[6 * i + 2],
                memberf[6 * i + 3],
                memberf[6 * i + 4],
                memberf[6 * i + 5],
                memberC[3 * i + 0].x,
                memberC[3 * i + 0].y,
                memberC[3 * i + 1].x,
                memberC[3 * i + 1].y,
                memberC[3 * i + 2].x,
                memberC[3 * i + 2].y);

            memberS[i].debugPrint();
        }
    }

    union
    {
        TestStructure memberS[10];
        cuComplex memberC[30];
        float memberf[60];
    };
};

void __global__ CreateA(void* devicePtr)
{
    ((TableTest*)devicePtr)->Initial();
    ((TableTest*)devicePtr)->Print();

    printf("\n");
}

void __global__ CreateB()
{
    TableTest* devicePtr2 = new TableTest();
    devicePtr2->Initial();
    devicePtr2->Print();
    delete devicePtr2;

    printf("\n");
}

int main()
{
    float* buffer1;
    cuComplex* buffer2;
    TestStructure* buffer3;
    TableTest* buffer4;

    cudaMalloc((void**)&buffer1, sizeof(float) * 60);
    cudaMalloc((void**)&buffer2, sizeof(cuComplex) * 30);
    cudaMalloc((void**)&buffer3, sizeof(TestStructure) * 10);
    cudaMalloc((void**)&buffer4, sizeof(TableTest) * 1);

    CreateA << <1, 1 >> > ((void*)buffer1);
    CreateA << <1, 1 >> > ((void*)buffer2);
    CreateA << <1, 1 >> > ((void*)buffer3);
    CreateA << <1, 1 >> > ((void*)buffer4);

    CreateB << <1, 1 >> >();

    cudaFree(buffer1);
    cudaFree(buffer2);
    cudaFree(buffer3);
    cudaFree(buffer4);
}


==============================================================================================

class alignas(8) ClassABC
{
public:
    __host__ __device__ ClassABC():m_iValue(0){ ;  }
    __device__ void Add(int v)
    {
        m_iValue += v;
        m_bySomeTag = static_cast<byte>(m_iValue & 0x11);
    }
    __device__ void DebugPrint() const
    {
        printf("%d,%d;", m_iValue, m_bySomeTag);
    }
    int m_iValue;
    byte m_bySomeTag;
};

class alignas(256) ClassDEF
{
public:
    __host__ __device__ ClassDEF() { ; }

    __device__ void Add(int v)
    {
        m_abc[10].Add(v);
        //m_values[10] += v; also work
    }

    __device__ void DebugPrint() const
    {
        m_abc[10].DebugPrint();
    }
    //Witout warning
    //device: ClassABC 4, ClassDEF 0
    //host: ClassABC 4, ClassDEF 80
    union 
    {
        ClassABC m_abc[20];
        int m_values[40];
    };

    //With warning
    //Output:
    //device: ClassABC 4, ClassDEF 0
    //host: ClassABC 4, ClassDEF 80
    //ClassABC m_abc[20];
};

__global__ void TestFunc()
{
    ClassDEF def[5];
    printf("device: ClassABC %d, ClassDEF %d\n", sizeof(ClassABC), sizeof(ClassDEF));

    for (int i = 0; i < 5; ++i)
    {
        def[i].Add(i);
        def[i].DebugPrint();
    }
}

int main()
{
    printf("host: ClassABC %d, ClassDEF %d\n", sizeof(ClassABC), sizeof(ClassDEF));

    //If use the version with warning, must set stack size, or there will be a stackoverflow.
    //checkCudaErrors(cudaDeviceSetLimit(cudaLimitStackSize, 1 << 16));
    TestFunc << <1, 1 >> > ();
    checkCudaErrors(cudaDeviceSynchronize());
    return 0;
}

